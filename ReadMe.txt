Target OS: Linux (Ubuntu 10.04)

The solution is split into two parts.
Task1
Task2

They are also the names of their folders.

How to Compile
---------------
The program can be run using the bash script provided.
The script is named compile.sh. It is available in both directory.

Here is how to run
--------------------

1. Open up a shell
2. Navigate to the directory where the programs are stored.
3. Ensure that the current directory has the compile.sh file.
4. Give this file "compile.sh" execution permission

chmod u+x compile.sh

5. Run the script 
./compile.sh

This should run the program as expected without any problems. The script helps handle all the classpath connectivity to the third party software need for the java parsing. Therefore, this connection is conveniently abstraction for the end user.

The compile.sh works the same for both Task1 and Task2 folders.

Content of the "Compile.sh" file
----------------------------------

This sets the classpath to the IBMjava for XMLparser called XML4J and Xerces parser. This is also a connection for unit testing with junit. This was not used in the project due to time constraint.

The script gets the path of the current directory and set this to the classpath. This allows you to use the program without taking care of setting classpaths.

Java Parser
------------
The following were used
IBM Java for XML parser
Xerces parser

There are two techniques for parsing an XML structure. They include:
DOM
SAX

This project made use of DOM as it structures are very similar to the data structures and algorithms lectures of traversing a tree. This equally simple for some problems. DOM worked well for the project.


Task1
------
Lets us analyze the solution in terms of relational database terms. A customer can have one or many addresses, one or many phone details, one or many email, and only one name and notes.

The notes can be taken as the description of the entity "Customer". The XMLDOM.java file contains the clas that allows us to parse through the XML structure and dump the result to the screen. The content of the XML file are used to set the field of a class object.

The getCustomer method in XMLDOM.jav file return a Customer object that is loaded with the text content of the XML file.

The code is heavily commented and provides more exact description of the manner in which it was solved.


Task2
------
The customer relationship with address, phone and email are very similar to Task1. The XML has a Customers tag as the root note that contains other customer. This can easily be abstracted in a programming language.e.g Arraylist of Customer object is Customers.

The program has a feature that tends to add an empty street tag are the required tags. This is no generally a problem as it is empty. This empty gives problem when parsing the XML file. This throws a nullpointerexception.

A good programmer solves the problems and not just caught this exception. I hads to think of tha way of prevent the creation of this empty street tag but could not find a ready-made solution. So as the deadline was approaching. I had to think of a clever hack.

The hack works this way, I read from an XML file as usually so after appending a street node it leave a last empty node. I saved changes to the XML file after every create, update or delete. The XML file is always a representation of the latest state of the data. This is actually the aim of persistent storage. I get the entire content of the XML file in a string. This string is match for regular expression relating to a empty tag.

We get a new string that has all the empty tags removed and save it in a new file. This file can easily be parsed by the application.It just returns all the ArrayList of Customer object.

The project has a Validation class to ensure that only suitable values can be added to the XML file. There is also a need to add a validation for the type tags. If the type tag is not validated when appending to the XML file. If the XML file is parsed, it will return a new value. This would give the impression of an error where not is existing.

The XMLDOM.java file has so many features can are well documented in the source code.

Features
--------
For the application to work as a CRUD application. Each Element needs an identifying key. I added an ID field to the customer. For the application to be efficient the ID should be internally generated by the application. This ID should be unique and have all the properties of a primary key.

To create a node
-----------------
Just create a child add the required grandchildren or even great grand children as required and add this child to the parent who is root.
This easy as it is added at the end of the children of the root nodes.

To update a node
-----------------
you use the ID to get the ID element of the customer node. Then you have to get the parent. From the parent you can modify what you like.
If the tag is unique, then you need only the  parent, child tags ,update value string and update the child tag.
If the child has duplicates, then you need only the  parent, child tags, old value in the child tag, update value string and update the child tag.

To delete a node
----------------
You the ID to get the ID of the customer and get the parent. You have to delete the parent from the root.


References
http://www.cs.unc.edu/~dewan/oe/colab/XMLEditor/xml4j_2_0_15/TXapiDocs/overview-summary.html

Pro XML Development with JavaTM Technology 2006 by Ajay Vohra and Deepak Vohra

Java & XML, 2nd Edition by Brett McLaughlin

XML and Java Developing Web Applications by Hiroshi Maruyama, Kent Tamura, 
Naohiko Uramoto; Addison Wesley First Edition May 04, 1999







